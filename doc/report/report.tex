\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{tipa}
\usepackage{../uebbgrammar}
\usepackage{listings}
\usepackage{url}
\usepackage{color}

% Declare the backslash from cmtt to use as terminal symbol in
% grammar.
\DeclareTextSymbol{\BackslashTT}{T1}{"5C}

\author{Benjamin Bisping, Rico Jasper, Sebastian Lohmeier,
	Friedrich Moritz Psiorz}
\title{Projektbericht: Erweiterung von SL um ein Modulsystem}
\institute{Compilerbauprojekt SoSe 2013, Technische Universität Berlin}

\newcommand{\verbatiminput}[2][]{%
  \lstinputlisting[basewidth=0.5em,
  columns=fixed,
  basicstyle=\small\ttfamily,#1]{#2}}
\newcommand{\TODO}[1]{ \textcolor{red}{\textbf{\texttt{\large{TODO}}} (* #1 *)}\par}

\begin{document}

\def\open{\texttt{(}}
\def\close{\texttt{)}}
\def\bropen{\texttt{\{}}
\def\brclose{\texttt{\}}}
\def\sqopen{\texttt{[}}
\def\sqclose{\texttt{]}}
\def\squote{\texttt{'}}
\def\dquote{\texttt{''}}
\def\eq{\texttt{=}}
\def\colon{\texttt{:}}
\def\lam{\mbox{\texttt{\BackslashTT}}}
\def\bar{\texttt{|}}
\def\comma{\texttt{,}}
\def\arrow{\texttt{->}}

\def\addint{\texttt{+}}
\def\subint{\texttt{-}}
\def\mulint{\texttt{*}}
\def\divint{\texttt{/}}

\def\ltint{\texttt{<}}
\def\leint{\texttt{<=}}
\def\eqint{\texttt{==}}
\def\neint{\texttt{/=}}
\def\geint{\texttt{>=}}
\def\gtint{\texttt{>}}

\def\exclamationOp{\texttt{!}}
\def\paragraphOp{\texttt{§}}
\def\percentOp{\texttt{\%}}
\def\ampOp{\texttt{\&}}
\def\questionOp{\texttt{?}}
\def\sharpOp{\texttt{\#}}
\def\pipeOp{\texttt{|}}

\maketitle


\section{Einleitung}

\TODO{Hällü Wörld}

\section{Überblick}

\TODO{Alle/Ben: Kurz die neuen Features bzw. den Ausgangspunkt beschreiben}

\section{Syntax und Parser}

\TODO{Fritz: Syntaxanpassungen, Schwierigkeiten, Designentscheidungen}

\subsection{Qualifizierte Bezeichner}

\subsection{Grammatik}

\section{Semantische Analyse}

\TODO{Rico: Methode, Schwierigkeiten, Designentscheidungen}

\subsection{Auflösung von Importen}

\subsection{Type-Checking}

\section{Codegenerierung}

\TODO{Sebastian: Beispiele, Schwierigkeiten, Designentscheidungen}

\TODO{Aufruf des Compilers, aus binary und in sbt, durchgehendes Beispiel}

Die Ausführung des generierten JavaScript-Codes wird in
node.js\footnote{http://nodejs.org/ - getestet mit Version 0.10.10
(\TODO{aktualisieren auf 0.10.13})},
Firefox\footnote{\TODO{URL, zum Testen benutzte Version und OS}},
Chrome\footnote{\TODO{URL, zum Testen benutzte Version und OS}} und
Internet Explorer\footnote{\TODO{URL, zum Testen benutzte Version und OS}}
unterstützt.

Bei Aufruf des Compilers mit
\begin{lstlisting}
$> <PROGRAMM-NAME> -d <outputDirectory> -cp <classpathDirectory>
[ -sourcepath <sourceDirectory> ] <moduleFile>
\end{lstlisting}

werden aus dem \texttt{<classpathDirectory>} die Signatur-Dateien
bereits kompilierter Module geladen, sowie das angegebene
\texttt{<moduleFile>} sowie alle von diesem transitiv verwendeten Module,
die noch nicht kompiliert im \texttt{<outputDirectory>} vorhanden sind
bzw. deren \TODO{keine Metonymie!} Modifikationsdatum im
\texttt{<outputDirectory>} vor dem Modifikationdatum der
SL-Moduldatei im \texttt{<sourceDirectory>} liegt, kompiliert. Dabei
werden Signaturen (siehe Abschnitt \ref{sec:compSig}), sowie
JavaScript-Dateien (siehe Abschnitt \ref{sec:compBuild}) für alle
kompilierten Module erstellt, wobei require.js (siehe Abschnitt
\ref{sec:compReq}) verwendet wird, um die JavaScript-Dateien der
Module zu laden. Sofern das beim Aufruf des Compilers angegebene
\texttt{<moduleFile>} eine Funktion namens
\texttt{main} deklariert, werden für dieses noch eine
\texttt{main.js}-Datei und eine \texttt{index.html}-Datei erstellt,
die den Aufruf der main-Funktion in node.js und im Browser erlauben
(siehe Abschnitt \ref{sec:compBuild}).

\TODO{Ausführung des Codes in (unterstützem) Browser und node.js,
Voraussetzungen dafür}

\subsection{Signaturen}
\label{sec:compSig}
\TODO{Das ist wohl eher für Rico...}

\subsection{require.js}
\label{sec:compReq}

Um die Module zur Laufzeit in JavaScript zu laden, wurde
require.js\footnote{http://requirejs.org/ v. 2.1.6 \TODO{updaten auf 2.1.8}}
statt CommonJS\footnote{http://www.commonjs.org/} ausgewählt, da es im
Gegensatz zum Modulsystem von node.js auch im Browser verfügbar ist,
jedoch auch in node.js genutzt werden kann\TODO{naja, das stimmt noch nicht ganz}.

In node.js stehen zwei Wege zur Verfügung, um Abhängigkeiten zwischen
Modulen zu deklarieren und zur Laufzeit aufzulösen, siehe Listings
\ref{lst:req1} und \ref{lst:req2}. \TODO{AMD besprechen?} Die
Moduldefinition mit einem Array von Abhängigkeiten (siehe Beispiel im
Listing \ref{lst:req1}) erlaubt den Zugriff auf verwendete Module,
können jedoch keine zirkulären statischen Abhängigkeiten auflösen, da
für die Erstellung der gegenseitig abhängigen Module jeweils das
andere Modul-Objekt als Parameter bei Erstellung des Moduls übergeben
werden muss. Dieses Problem wird in require.js mittels
Export-Objekten gelöst, die beim Erstellen eines Moduls übergeben und
zur Laufzeit verwendet werden (siehe Beispiel im Listing
\ref{lst:req2}). Die Moduldefinition mit Export-Objekten wurde in SL2
gewählt, um später statische zirkuläre Abhängigkeiten auflösen zu
können, auch wenn die bisherige Implementierung des Compilers dies
nicht erlaubt.

\begin{lstlisting}{caption={Moduldefinition mit Abhängigkeits-Array},label=lst:req1}
define(["modules/B"], function(b) {
  return {
    "a" : function() { return "A.a"; },
    "b" : function() { return b.b(); }
  };
});
\end{lstlisting}

\begin{lstlisting}{caption={Moduldefinition mit Export-Objekt},label=lst:req2}
define(function(require, exports, module) {
  var b = require("modules/B");
  exports.a = function() { return "A.a"; };
  exports.b = function() { return b.b(); };
});
\end{lstlisting}

\TODO{Kompilierung der Module}

\TODO{Kompilierung der main-Funktion}

\TODO{Designentscheidung für require.js-Verwendung, die theoretisch
auch statisch zirkuläre Abhängigkeiten auflösen kann}
\TODO{require.js wird mitgeliefert, sodass es für Ausführung im
Browser nicht installiert werden muss}
\TODO{Installation von requirejs in node.js -- im lokalen Verzeichnis
oder global? in Systemvoraussetzungen für SL2 beschreiben}

\subsection{Build-Prozess}
\label{sec:compBuild}

\TODO{implizit unqualifiziert importieres prelude aus dem
resources-Verzeichnis der SL2-Distribution, Zugriffe darauf werden
nach dem Typcheck qualifiziert mit /lib/prelude -- bzw. mit /lib/prelude}

\TODO{Übersetzung der / (oder aller nicht-zugelassenen Zeichen) zu \$
in JavaScript?}

\TODO{Ort, an dem die Templates, prelude, und require.js (im Distributable)
gespeichert sind}

\subsection{Externe Definitionen}
\TODO{Das ist wohl eher für Ben...}

\section{Prelude und Bibliotheken}

\TODO{Ben: Beispiele, Schwierigkeiten, Designentscheidungen}


\subsection{Prelude}

Alle vormals fest in den Compiler eingebauten Funktionen und Konstruktoren
werden jetzt durch ein eigenes, umfangreicheres Prelude-Modul definiert.
Dieses wird implizit durch jedes SL-Programm unqualifiziert importiert.
Im Prelude werden auch alle Basistypen deklariert. (Allerdings sind diese
gleichzeitig noch in den Compiler integriert, damit die Literale einen Typ
unabhängig vom Prelude-Import erhalten können.)

Unter anderem sind \verb|#| für Funktionskomposition und \verb|id| als
Identitätsfunktion im Prelude hinzugekommen.

\begin{lstlisting}{caption={Prelude},label=lst:prelude}
PUBLIC DATA Bool = True | False
PUBLIC FUN not : Bool -> Bool

-- Function composition
PUBLIC FUN # : (b -> c) -> (a -> b) -> (a -> c)
PUBLIC FUN id : a -> a

-- String functions

PUBLIC FUN ++ : (String -> String -> String)

-------------------------------------

PUBLIC FUN intToStr : Int -> String
PUBLIC FUN strToInt : String -> Int

\end{lstlisting}

\subsection{Error}

\begin{verbatim}
PUBLIC FUN error : String -> a
DEF EXTERN error = {| function(msg){throw msg} |} 
\end{verbatim}

Eine spannende neue Funktion im Prelude ist \verb|error|. Diese hat einen
beliebigen Rückgabetyp, kann also an beliebigen Stellen in den Code
geschrieben werden. Allerdings wird \verb|error| niemals einen Wert
zurückgeben, sondern schlicht das Programm mit einer Fehlermeldung enden
lassen.\footnote{Diese Funktion ist also keine echte, wohldefinierte Funktion,
sondern hat dasselbe ``Ergebnis'' wie eine Endlosrekursion.} Das ist sehr
praktisch, wenn man im Implementierungsprozess schon teile Testen möchte,
aber noch nicht überall sinnvollen Code eintragen kann.

\subsection{println-Debugging}

\begin{verbatim}
PUBLIC FUN print : String -> DOM Void
PUBLIC FUN andPrint : a -> (a -> String) -> a
PUBLIC FUN andPrintDbg : a -> String -> a
\end{verbatim}

Mit einem ähnlichen Trick arbeitet das neue Modul \verb|basicio|. Dieses
erlaubt, normale Programme mit Konsolenausgaben zu versehen, die neben
der Programmausführung ausgegeben werden.

\begin{verbatim}
IO.andPrint (L.Cons 1 (L.Cons 2 L.Nil)) (L.toString intToStr)
\end{verbatim}

Dieser Ausdruck hat als Rückgabewert die Liste $\langle1,2\rangle$,
während als (fürs Programm hoffentlich unsichtbarer) Seiteneffekt,
noch \verb|"<1,2>"| auf die Konsole geschrieben wird. Semantisch sollten
\verb|andPrint| sowie \verb|andPrintDbg| äquivalent zur Identitätsfunktion
mit ein paar unnötigen Parametern sein.

\subsection{List, Option, Either}

\begin{verbatim}
PUBLIC DATA List a     = Nil | Cons a (List a)
PUBLIC DATA Option a   = None | Some a
PUBLIC DATA Either a b = Left a | Right b
\end{verbatim}

Unsere mitgelieferten Module enthalten die klassischen algebraischen,
generischen Datentypen \verb|List| (aka Sequence), \verb|Option| (aka Maybe)
und \verb|Either| (aka Union). Bis auf \verb|List.fromString| sind diese
Module komplett in SL geschrieben ohne Rückgriff auf JavaScript. Wir
haben auch ein paar der grundlegenden Funktionen wie \verb|map| und
\verb|reduce| implementiert. Vorrangig ging es uns aber darum, komplexere
importierte Konstruktoren beim Pattern Matching anhand dieser Typen
auszuprobieren.

\subsection{Dictionarys}

Der abstrakte Datentyp \verb|Dict| hingegen ist komplett ohne SLs
algebraische Datentypen umgesetzt. Stattdessen arbeiten die Implementierungen
der einzelnen Funktionen ausschließlich mit JavaScripts \verb|Object|,
also den in JavaScript grundlegenden Wörterbuchobjekten.

\begin{verbatim}
DATA Dict a
PUBLIC FUN empty : Dict a
PUBLIC FUN put : Dict a -> String -> a -> Dict a
PUBLIC FUN get : Dict a -> String -> a
PUBLIC FUN has : Dict a -> String -> Bool
\end{verbatim}

\subsection{Browseranbindung}

\subsection{Floats}

\section{Fehlermeldungen}
\TODO{Fritz}

\section{Zusammenfassung}

\TODO{...}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% End: 
